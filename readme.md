Задача Pyhon – иерархическое получение данных
=======================
Описание проекта
----------------
Данная утилита позволяет получать расположение офиса компании и список сотрудников, 
которые в нем работают при помощи ввода идентификационного номера сотрудника

Файлы проекта
------------


      /               
            sql/           файлы sql запросов, которые импользуются для работы

      app.py               файл утилиты
      settings.py          файл настройки для базы данных
      staff.json           json файл для загрузки в базу данных
      reqs.txt             setup файл со сторонними библиотеками
      README.md            readme

#### Используемые компоненты

postgresql 10.0
psycopg 2.8.3

#### Этапы работ

###### Подготовка бд

СУБД была развернута на ubuntu server на azure. Конфиг подключения находится
в файле settings.py

Была создана база данных, схема таблицы staff, куда были загруженны данные из файла json.

###### Написание файла

Файл позволяет пользователю подключиться к базе данных и после успешного подключения 
дает возможноть ввести число (id сотрудника). Вводить можно только числа, иначе будет вызвана ошбика.

При помощи psycopg заранее написанный sql запрос выполняется на базе данных и возвращает результат.

###### Написание sql запроса
Работа над написанием запроса заняла основную часть времени. 
Поскольку данные представляют собой дерево, и каждый элемент дерева имеет ссылку на родительский элемент,
удобно использовать рекурсию для перебора всех значений в дереве. Сперва был найдет главный родительский элемент, а за тем
по найденному элементу были найдены все дочерние элементы.

С точки зрения оптимальности запрос получился слабо оптимизированным из-за следующих особенностей:
1. Запрос содержал в себе несколько рекурсий, причем одна вызывается из другой. При оптимизации следует выполнять их при помощи метода
union или join, чтобы сократить время
2. В первой рекурсии запрос собирал все родительские элементы, как приближенные к элементу, так и отдаленные.
Во второй рекурсии были выполнены теже действия, только ко всем родительским элементам были найдены все приближенные и удлаенные элементы.
Поиск приближенных элементов не являлся условием задачи, однако без них невозможно было бы найти удаленные элементы. Поиск способа не 
сохранять промежуточные элементы увеличит оптимальность запроса.
3. **explain** показал, что сферическое время на операцию примерно составило 774.37..774.39, 
    среди которых на рекурсии пришлось около 70%, если бы к этому значению добавим агреграцию данных, то получит порядка 95%
    


Выполнил Вадим Кропотин https://supahero.github.io/supahero-cv/index.html
